shirlel25,talia3
325000057,211449483

1. BasicCollisionStrategy Receiving GameObjectCollection:
We believe the best approach to managing the list of game objects is Option 2: delegating the responsibility
of adding or deleting objects to the GameObjectCollection class exclusively. This ensures that the
encapsulation principle is adhered to in the best way possible.

Advantages:
    1) Separation of Concerns:
        Managing the collection of game objects is centralized in a single class, simplifying the tracking of
        changes and avoiding code duplication.

    2) Encapsulation Principle:
        The object list is managed privately within the GameObjectCollection, hiding implementation details
        from other classes. This makes it easier to modify the underlying data structure or logic without
        affecting external code.

    3) Improved Maintainability:
        All modifications to the list are handled in one place, reducing the risk of bugs and making the code
        easier to maintain and extend.

    4) Code Reusability:
        By encapsulating the logic within GameObjectCollection, other components of the system can reuse its
        functionality without needing to duplicate code.

Disadvantages:

    1) Increased Complexity in GameObjectCollection:
        Centralizing all logic may make the GameObjectCollection class more complex as it grows to accommodate
         various use cases.

    2) Dependency on GameObjectCollection:
        Other classes are tightly coupled to the GameObjectCollection's interface, meaning changes to its API
        could impact multiple components.

2. We created two classes to represent different types of hearts in the game: GraphicHeart and NumericHeart.
The NumericHeart class specifically handles the numeric representation of the player's remaining lives.

In the NumericHeart class, there is a public method that dynamically updates the numeric heart's
appearance during the game. This method updates two key elements:

    1) Text Renderer: Displays the current number of lives in text form.

    2) Color: Changes the text's color based on the remaining number of lives,
       visually indicating the player's health status.

GraphicHeart Class:
API:
GraphicHeart Constructor:
Initializes the GraphicHeart object.

onCollisionEnter Method (Collision Handling):
We added an overridden version of the onCollisionEnter method to handle the collision between the falling
heart and the paddle. This calls the increaseLives function from the BrickerGameManager,
because it is the manager's responsibility to track and update the number of lives in the game.

shouldCollideWith Method:
We added an overridden version of the shouldCollideWith method to ensure the falling heart can only collide
 with the main paddle.

onCollisionEnter Method (Out of Bounds Handling):
We added an overridden version of the onCollisionEnter method to handle the case where the falling heart
goes out of the game borders. In such a case, the heart is removed by the BrickerGameManager,
because its his responsabilty to mange the game object

3. Every collision strategy we made as a class that implements the CollisionStrategy interface.
In every strategy, the basicCollisionStrategy instance is sent as a parameter to the
constructor to manage the basic removal of the brick.
In addition, every strategy uses the brickerGameManager from the public field of the basicCollisionStrategy
for the creation of new game objects.

The ExtraBallCollisionStrategy:
We added an overridden version of the onCollision method that creates two puck balls with the
specific attributes and add them to the game.

The TurboCollisionStrategy:
The overridden version of the onCollision method, activates the mode of the ball to turboMode.
This mode indicates the ball to change its attributes and start counting its number of collisions with
other game object. From the moment of the turbo mode activation, its the balls responsibility to
make the changes and also get back to its normal mode. Because only the ball itself has the knowledge of
its collisions with other game objects. Thus we ensure the encapsulation principle.

The ExtraPaddleCollisionStrategy:
We added an overridden version of the onCollision method to add an extra paddle only if it does not
already exist. This is determined by a public boolean function, doesExtraPaddleExist, implemented
in the brickerGameManager.
It is the responsibility of the brickerGameManager to keep track of the objects currently
present in the game. By encapsulating this logic, other classes
(like ExtraPaddleCollisionStrategy and Paddle) focus on their specific behaviors without needing
to handle this case.

The ExtraLifeCollisionStrategy:
We added an overridden version of the onCollision method to handle the collision between a brick and
the ball as follows:
Additionally, we added a constant for the velocity of the falling heart (FALLING_HEART_Y_VELOCITY).
The logic for setting this velocity is encapsulated in this strategy because it is solely the responsibility
of the ExtraLifeCollisionStrategy to determine the behavior and properties of the falling heart.

4. We implemented the DoubleBehaviorCollisionStrategy that combines two collision strategies,
   allowing a collision strategy to trigger multiple behaviors simultaneously.
   This was done by creating a recursive method in the DoubleBehaviorCollisionStrategy class that
   randomly selects and wraps different collision strategies.

   Key Design Elements:
   Strategy Factory: The StrategyFactory class provides the creation of various collision strategies.
   Double Wrapping: In DoubleBehaviorCollisionStrategy, we execute the onCollision methods of the
   two strategies simultaneously.
   Random Selection: A recursive method in createStrategy randomly determines whether to combine behaviors
   (the prevWasDouble flag) or return a single basic behavior.
   Limiting to 3 Behaviors:
   Depth Control: The prevWasDouble boolean Flag ensures that only one recursive level of
   double wrapping is allowed.
   This prevents excessive depth and recursion by stopping the combination after reaching the
   specified depth limit, ensuring no more than three strategies are combined.


5.
BasicCollisionStrategy API:
We made the brickerGameManager a protected field, so that every strategy that gets the
basicCollisionStrategy instance could use it. Instead of sending it as a parameter to every strategy,
when not all of them are using its functionality.
The brickerGameManager is necessary for the following strategies:
ExtraBallCollisionStrategy to create the puck balls,
ExtraLifeCollisionStrategy to create the graphic heart,
TurboCollisionStrategy to make the renderable of the turbo ball,
ExtraPaddleCollisionStrategy to make the extra paddle.

Ball API:
We added three public methods to manage the ball's turbo mode when activated. These methods ensure that
the ball itself handles its own attributes, adhering to the encapsulation principle by keeping the
responsibility for modifying the ball's attributes within the ball class.

   1) activateTurbo Method:
        This method activates turbo mode and updates the ball's attributes accordingly.

   2) getTurboMode Method:
        This is a getter for the turboMode field, indicating whether turbo mode is currently active.
        It allows the TurboCollisionStrategy to check the turbo mode status without directly accessing
        the ball's internal implementation.

   3) resetBall Method:
        This method resets the ball to its original attributes and deactivates turbo mode by resetting
        the turboMode field. It ensures that the TurboCollisionStrategy can reactivate turbo mode
        when needed.

By handling turbo mode logic entirely within the ball class, we minimize the coupling between the
TurboCollisionStrategy and the ball class, ensuring clean separation of concerns and better
maintainability.

Paddle API:

We added two overridden methods to manage the Extra Paddle mode when activated.
These methods ensure that the Paddle class itself handles its attributes, adhering to the encapsulation
principle by keeping the responsibility for modifying the Paddle's attributes within the Paddle class.

    1) onCollisionEnter Method:
        This method handles the extra paddle attribute, ensuring it is removed after the paddle is hit 4 times.
        The Paddle class is responsible for counting these hits, maintaining the encapsulation principle.

    2) update Method:
        This method updates the behavior of the paddle during each frame.

By handling the Extra Paddle mode logic entirely within the Paddle class, we minimize coupling
between the ExtraPaddleCollisionStrategy and the Paddle class. This ensures a clean separation of
concerns and improves maintainability.
